from snakemake.utils import min_version
from pathlib import Path
from yaml import dump
min_version("6.0")

import sys

worflow_source_dir = Path(next(iter(workflow.get_sources()))).absolute().parent
common = str(worflow_source_dir / "../common/python")
sys.path.append(common)

from dataframes import *
from file_manager import *
from files_linker import *
from graphics import *
from write_yaml import *
from messages import message


#################
### Preambule ###
#################

logging.basicConfig(
    filename="snakemake.miraseq.log",
    filemode="w",
    level=logging.DEBUG
)

default_config = read_yaml(worflow_source_dir / "config.hg38.yaml")
configfile: get_config(default_config)
design = get_design(os.getcwd(), search_fastq_files_dict)

fastq_links = {}
if config["params"].get("Paired", False) is True:
    fastq_links = link_fq(
        design.Sample_id,
        design.Upstream_file,
        design.Downstream_file
    )
else:
        fastq_links = link_fq(
        design.Sample_id,
        design.Upstream_file
    )

##############
### Target ###
##############

rule target:
    input:
        bismark=expand(
            "bismark/report/{sample}.SE.html",
            sample=design["Sample_id"].tolist()
        ),
        multiqc="results/MiraSeq.html"


####################################
### FastQ Screen and MultiQC     ###
####################################


rule multiqc:
    input:
        html=expand(
            "fastp/html/pe/{sample}.fastp.html",
            sample=design["Sample_id"]
        ),
        json=expand(
            "fastp/json/pe/{sample}.fastp.json",
            sample=design["Sample_id"]
        ),
        txt=expand(
            "fastq_screen/{sample}.fastq_screen.txt",
            sample=design["Sample_id"],
            stream=["1", "2"]
        ),
        png=expand(
            "fastq_screen/{sample}.fastq_screen.png",
            sample=design["Sample_id"],
            stream=["1", "2"]
        ),
        bismark_alignment_report=expand(
            "bismark/bams/{sample}_SE_report.txt",
            sample=design["Sample_id"].tolist()
        ),
        bismark_nucleotide_report=expand(
            "bismark/bams/{sample}.SE.nucleotide_stats.txt",
            sample=design["Sample_id"].tolist()
        ),
        bismark_dedup_report=expand(
            "bismark/deduplicated/{sample}.SE.deduplication_report.txt",
            sample=design["Sample_id"].tolist()
        ),
        bismark_mbias_report=expand(
            "bismark/meth/{sample}.SE.M-bias.txt",
            sample=design["Sample_id"].tolist()
        ),
        bismark_splitting_report=expand(
            "bismark/meth/{sample}_SE_splitting_report.txt",
            sample=design["Sample_id"].tolist()
        )
    output:
        report(
            "results/MiraSeq.html",
            caption="../common/reports/multiqc.rst",
            category="Quality Controls"
        )
    message:
        "Aggregating quality reports from Fastp and Salmon"
    threads: 1
    resources:
        mem_mb=lambda wildcards, attempt: min(attempt * 1536, 10240),
        time_min=lambda wildcards, attempt: attempt * 35
    log:
        "logs/multiqc.log"
    wrapper:
        "bio/multiqc"


rule fastq_screen:
    input:
        "reads/{sample}.fq.gz"
    output:
        txt="fastq_screen/{sample}.fastq_screen.txt",
        png="fastq_screen/{sample}.fastq_screen.png"
    message:
        "Assessing quality of {wildcards.sample}"
    threads: config.get("threads", 20)
    resources:
        mem_mb=lambda wildcard, attempt: min(attempt * 4096, 8192),
        time_min=lambda wildcard, attempt: attempt * 50
    params:
        fastq_screen_config=config["fastq_screen"],
        subset=100000,
        aligner='bowtie2'
    log:
        "logs/fastq_screen/{sample}.log"
    wrapper:
        "bio/fastq_screen"


###################
### Methylation ###
###################


bismark_config = {
    "genome": config["ref"]["genome"],
    "paired": config["params"].get("Paired", True)
}

module bismark:
    snakefile: "../../meta/bio/bismark/test/Snakefile"
    config: bismark_config


use rule * from bismark as *


############################
### FASTP FASTQ CLEANING ###
############################

rule fastp_clean:
    input:
        sample="reads/{sample}.fq.gz"
    output:
        trimmed="fastp/trimmed/pe/{sample}.fastq",
        html="fastp/html/pe/{sample}.fastp.html",
        json=temp("fastp/json/pe/{sample}.fastp.json")
    message: "Cleaning {wildcards.sample} with Fastp"
    threads: 1
    resources:
        mem_mb=lambda wildcards, attempt: min(attempt * 4096, 15360),
        time_min=lambda wildcards, attempt: attempt * 45
    params:
        adapters=config["params"].get("fastp_adapters", None),
        extra=config["params"].get("fastp_extra", "")
    log:
        "logs/fastp/{sample}.log"
    wrapper:
        "bio/fastp"


#################################################
### Gather files from iRODS or mounting point ###
#################################################

rule bigr_copy:
    output:
        "reads/{sample}.fq.gz"
    message:
        "Gathering {wildcards.sample} fastq file"
    threads: 1
    resources:
        mem_mb=lambda wildcards, attempt: min(attempt * 1024, 2048),
        time_min=lambda wildcards, attempt: attempt * 45
    params:
        input=lambda wildcards, output: fastq_links[output[0]]
    log:
        "logs/bigr_copy/{sample}.log"
    wrapper:
        "bio/BiGR/copy"
