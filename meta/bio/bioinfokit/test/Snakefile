import os.path

from typing import Optional

default_config = {
    "thresholds":{
        "alpha": 0.05,
        "fc_threshold": 0.01
    },
    "bioinfokit": {
        "maplot_extra": {
            "lfc": "log2FoldChange",
            "ct_count": "a.chr21",
            "st_count": "e.chr21"
        },
        "heatmap_extra": {
            "rowclus": True,
            "colclus": True
        },
        "volcanoplot_extra": {
            "lfc": "log2FoldChange",
            "pv": "padj",
            "geneid": "Unnamed: 0",
            "lfc_thr": (0.001, 0.001),
            "pv_thr": (0.05, 0.05),
            "gstyle": 2,
            "sign_line": True,
            "plotlegend": True
        }
    }
}

try:
    if config == dict():
        config = default_config
except NameError:
    config = default_config

def rst_exists(path: str) -> Optional[str]:
    """
    If a provided rst path exists, then it is returned,
    otherwise "None" is returned.
    """
    return path if os.path.exists(path) else None

volcanoplot_rst = rst_exists("reports/bioinfokit_volcanoplot.rst")
bioinfokit_heatmap_rst = rst_exists("reports/bioinfokit_heatmap.rst")
bioinfokit_maplot_rst = rst_exists("reports/bioinfokit_maplot.rst")


"""
This rule builds a Volcanoplot from DESeq2 results
"""
rule bioinfokit_volcanoplot:
    input:
        "deseq2/wald/Cond_compairing_B_vs_A.tsv"
    output:
        report(
            "bioinfokit/figures/volcanoplot.png",
            caption=volcanoplot_rst,
            category="Volcano-Plot"
        )
    message: "Plotting Volcanoplot with Bioinfokit"
    threads: 1
    resources:
        mem_mb=lambda wildcards, attempt: min(attempt * 2048, 10240),
        time_min=lambda wildcards, attempt: attempt * 20
    params:
        read_csv={
            "header": 0,
            "index_col": None
        },
        volcano=config["bioinfokit"].get("volcanoplot_extra", {
            "lfc": "log2FoldChange",
            "pv": "padj",
            "geneid": "Unnamed: 0",
            "lfc_thr": (0.001, 0.001),
            "pv_thr": (0.05, 0.05),
            "gstyle": 2,
            "sign_line": True,
            "plotlegend": True
        })
    log:
        "logs/bioinfokit/volcanoplot.log"
    wrapper:
        "master/bio/bioinfokit/volcanoplot"

"""
This rule creates a sample clustered heatmap from the filtered-counts table
"""
rule bioinfokit_sample_heatmap:
    input:
        "deseq2/filtered/filtered_counts.tsv"
    output:
        report(
            "bioinfokit/figures/sample_heatmap.png",
            caption=bioinfokit_heatmap_rst,
            category="Clustered Heatmap"
        )
    threads: 1
    resources:
        mem_mb=lambda wildcard, attempt: min(attempt * 2048, 10240),
        time_min=lambda wildcards, attempt: attempt * 20
    params:
        read_csv={
            "header": 0,
            "index_col": 0
        },
        hmap=config["bioinfokit"].get("heatmap_extra", {
            "rowclus": True,
            "colclus": True
        })
    log:
        "logs/bioinfokit/sample_heatmap.png"
    wrapper:
        "master/bio/bioinfokit/heatmap"


"""
This rule creates a MA-plot from DESeq2 merged results
"""
rule bioinfokit_maplot:
    input:
        "deseq2/filtered/merged.tsv"
    output:
        report(
            "bioinfokit/figures/maplot.png",
            caption=bioinfokit_maplot_rst,
            category="MA-Plot"
        )
    message: "Building MA-plot"
    threads: 1
    resources:
        mem_mb=lambda wildcard, attempt: min(attempt * 2048, 10240),
        time_min=lambda wildcards, attempt: attempt * 20
    params:
        read_csv={
            "header": 0,
            "index_col": 0
        },
        maplot=config["bioinfokit"].get("maplot_extra", {
            "lfc": "log2FoldChange",
            "ct_count": "a.chr21",
            "st_count": "e.chr21"
        })
    log:
        "logs/bioinfokit/maplot.png"
    wrapper:
        "master/bio/bioinfokit/maplot"


"""
This rule merges and filters both DESeq2 counts and results for further graphs
"""
rule filter_deseq2:
    input:
        wald_tsv = "deseq2/wald/Cond_compairing_B_vs_A.tsv",
        dst_tsv = "deseq2/dst/Cond_compairing_B_vs_A.tsv",
        gene2gene = "tximport/gene2gene.tsv"
    output:
        filtered_counts="deseq2/filtered/filtered_counts.tsv",
        filtered_deseq2="deseq2/filtered/filtered_deseq2.tsv",
        merged_table="deseq2/filtered/merged.tsv"
    message: "Filtering and merging DESeq2 results"
    threads: 1
    resources:
        mem_mb=lambda wildcard, attempt: attempt * 4096,
        time_min=lambda wildcard, attempt: attempt * 20
    params:
        alpha=config["thresholds"].get("deseq2_alpha", 0.05),
        fc_threshold=config["thresholds"].get("fc_threshold", 0.01)
    log:
        "logs/deseq2/filter.log"
    wrapper:
        "master/bio/pandas/deseq2_merge"



"""
This rule build the conversion table from transcript to genes and their names.
"""
rule gene_to_gene:
    input:
        gtf="refs/ensembl/chr21.gtf"
    output:
        gene2gene_large="tximport/gene2gene.tsv"
    message: "Building transcripts/genes conversion table"
    cache: True
    threads: 1
    resources:
        mem_mb=lambda wildcard, attempt: attempt * 1536,
        time_min=lambda wildcard, attempt: attempt * 45
    params:
        gencode = True,
        header = True,
        positions = True
    log:
        "logs/tximport/tx2gene.log"
    wrapper:
        "master/bio/gtf/tx2gene"
