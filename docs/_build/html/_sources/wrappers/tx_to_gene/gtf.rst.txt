.. _`GTF`:

GTF
===

Build a transcript / gene correspondancy table from a GTF



Software dependencies
---------------------


* conda-forge:python=3.8.2




Example
-------

This wrapper can be used in the following way:

.. code-block:: python

    rule tx_to_gene:
        input:
            gtf = "file.gtf"
        output:
            tsv = "tx2gene.tsv"
        message:
            "Testing tx_to_gene"
        threads:
            1
        resources:
            mem_mb = (
                lambda wildcards, attempt: min(attempt * 512, 1024)
            ),
            time_min = (
                lambda wildcards, attempt: min(attempt * 10, 15)
            )
        log:
            "logs/tx_to_gene.log"
        wrapper:
            "0.50.4-62-g6050183/bio/tx_to_gene/gtf"


Note that input, output and log file paths can be chosen freely.
When running with

.. code-block:: bash

    snakemake --use-conda

the software dependencies will be automatically deployed into an isolated environment before execution.



Notes
-----

Parameters:

* header (bool) : Weather to write column header or not
* positions (bool) : Weather to write positions or not

The output file contains:

+--------+--------------+----------+------------+----------+----------+
| GeneID | TranscriptID | GeneName | Chromosome | Start    | Stop     |
+========+==============+==========+============+==========+==========+
| Awlays | Always       | Always   | Optional   | Optional | Optional |
+--------+--------------+----------+------------+----------+----------+




Authors
-------


* Thibault Dayris



Code
----

.. code-block:: python

    #!/usr/bin/python3.8
    # conding: utf-8

    """
    This script extracts a tsv from a GTF. This tsv contains gene_id,
    transcript_id, gene_name. Optionaly, headers and positions can
    also be given.
    """

    __author__ = "Thibault Dayris"
    __copyright__ = "Copyright 2020, Thibault Dayris"
    __email__ = "thibault.dayris@gustaveroussy.fr"
    __license__ = "MIT"

    gtf_in = snakemake.input["gtf"]
    tsv_out = snakemake.output["tsv"]

    with open(gtf_in, "r") as gtf, open(tsv_out, "w") as tsv:
        # Write header on user request
        if snakemake.params.get("header", False) is True:
            cols = (
                ["Gene_ID", "Transcript_ID", "Gene_Name",
                 "Chromosome", "Start", "Stop", "Strand"]
                if snakemake.params.get("positions", False) is True else
                ["Gene_ID", "Transcript_ID", "Gene_Name"]
            )
            tsv.write('\t'.join(cols))
            tsv.write("\n")

        for line in gtf:
            if line.startswith("#"):
                # Then is it a comment
                continue

            # If the line is not a transcript, then it will no contain
            # the required information
            chomp = line[:-1].split("\t")
            if chomp[2] != "transcript":
                continue

            start = chomp[3]
            stop = chomp[4]
            chrom = chomp[0]
            strand = chomp[6]

            # We are interested in the last column
            chomp = {
                attr.split('"')[0].strip(): attr.split('"')[1].strip()
                for attr in chomp[8].split(";")
                if attr != '' and '"' in attr
            }

            if snakemake.params.get("gencore", False) is True:
                chomp["gene_id"] = chomp["gene_id"].split(".")[0]
                chomp["transcript_id"] = chomp["transcript_id"].split(".")[0]

            # Some genes have an ID but no name ...
            try:
                result = [
                    chomp["gene_id"],
                    chomp["transcript_id"],
                    chomp["gene_name"]
                ]
            except KeyError:
                result = [
                    chomp["gene_id"],
                    chomp["transcript_id"],
                    chomp["gene_id"]
                ]

            if snakemake.params.get("positions", False) is True:
                tsv.write("\t".join(result + [chrom, start, stop, strand]) + "\n")
            else:
                tsv.write("\t".join(result) + "\n")
